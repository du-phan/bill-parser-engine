"""
Data models for the reference resolver.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Tuple, Any


# --- Enums ---

class TargetOperationType(Enum):
    INSERT = "INSERT"
    MODIFY = "MODIFY"
    ABROGATE = "ABROGATE"
    RENUMBER = "RENUMBER"
    OTHER = "OTHER"

class ReferenceSourceType(Enum):
    DELETIONAL = "DELETIONAL"
    DEFINITIONAL = "DEFINITIONAL"


@dataclass
class TargetArticle:
    """Identifies the legal article being targeted by an amendment chunk."""
    operation_type: TargetOperationType
    code: Optional[str]
    article: Optional[str]
    confidence: Optional[float] = None
    # Optional reason for OTHER classification (e.g., 'suppressed_enumeration')
    reason: Optional[str] = None

@dataclass
class ReconstructorOutput:
    """
    Output model for text reconstruction with FOCUSED REFERENCE RESOLUTION support.
    
    STEP 1 IMPLEMENTATION: This model implements the focused output data contract
    that enables the 30x+ performance improvement in reference location processing.
    
    FOCUSED REFERENCE RESOLUTION APPROACH:
    =====================================
    
    Traditional Problem:
    - Mixed all changes together in single field
    - Downstream components scanned entire article text (3000+ chars)
    - Wasted computational resources on unchanged text
    - Slower processing and higher API costs
    
    Focused Solution:
    - Separates deleted_or_replaced_text from newly_inserted_text
    - Enables scanning only changed fragments (~80 chars)
    - Provides 30x+ performance improvement
    - Maintains accuracy while dramatically reducing processing time
    
    THREE-FIELD ARCHITECTURE:
    ========================
    
    1. deleted_or_replaced_text: Text that was removed or replaced
       → Contains DELETIONAL references (references being removed from law)
       → Used by ReferenceLocator for focused scanning of removed content
       → Enables proper context for object linking (original law context)
       
    2. newly_inserted_text: Text that was added or inserted
       → Contains DEFINITIONAL references (references being added to law)  
       → Used by ReferenceLocator for focused scanning of new content
       → Enables proper context for object linking (amended text context)
       
    3. intermediate_after_state_text: Complete article after all changes
       → Preserved for context and other downstream needs
       → NOT used for reference scanning (would defeat the performance gains)
       → Available for final validation and full-text operations
    
    REFERENCE CLASSIFICATION IMPACT:
    ===============================
    This separation enables proper classification of references by source type:
    
    - DELETIONAL references: Found in deleted_or_replaced_text
      → Need original law context for proper object linking
      → Represent legal citations being removed from legislation
      
    - DEFINITIONAL references: Found in newly_inserted_text
      → Need amended text context for proper object linking  
      → Represent legal citations being added to legislation
      
    Different reference types require different contextual analysis in downstream
    components, making this separation crucial for accuracy.
    
    PERFORMANCE BENEFITS:
    ====================
    - 30x+ speed improvement in reference location
    - Reduced API costs (fewer tokens processed)
    - Maintained reference detection accuracy
    - Enables real-time legislative processing
    - Scales efficiently to large legislative documents
    
    PIPELINE INTEGRATION:
    ====================
    - Generated by LegalAmendmentReconstructor (Step 4)
    - Consumed by ReferenceLocator for focused scanning (Step 5)
    - Enables the entire focused reference resolution approach
    - Maintains backward compatibility with existing pipeline components
    """
    deleted_or_replaced_text: str
    newly_inserted_text: str
    intermediate_after_state_text: str

@dataclass
class LocatedReference:
    """
    Represents a reference found in a text fragment, tagged by its source.
    
    This simplified model focuses on what's actually needed downstream:
    - The reference text for matching and substitution
    - The source type for context-aware processing
    - Confidence for quality filtering
    
    Position fields have been removed as they were error-prone and not used
    meaningfully by downstream components.
    """
    reference_text: str
    source: ReferenceSourceType
    confidence: float

@dataclass
class LinkedReference:
    """Represents a reference that has been grammatically linked to its object."""
    reference_text: str
    source: ReferenceSourceType
    object: str
    agreement_analysis: str
    confidence: float
    resolution_question: str  # Added for Step 3: focused reference resolution

@dataclass
class ResolutionResult:
    """The complete output from the ReferenceResolver."""
    resolved_deletional_references: List["ResolvedReference"]
    resolved_definitional_references: List["ResolvedReference"]
    resolution_tree: Dict
    unresolved_references: List[LinkedReference]

@dataclass
class ResolvedReference:
    """Contains a linked reference and its fetched content."""
    linked_reference: LinkedReference
    resolved_content: str
    retrieval_metadata: Dict[str, str]

@dataclass
class BillChunk:
    """Represents an atomic, processable piece of a legislative bill, as output by the BillSplitter."""
    text: str
    titre_text: str
    article_label: str
    article_introductory_phrase: Optional[str]
    major_subdivision_label: Optional[str]
    major_subdivision_introductory_phrase: Optional[str]
    numbered_point_label: Optional[str]
    numbered_point_introductory_phrase: Optional[str]
    lettered_subdivision_label: Optional[str]
    hierarchy_path: List[str]
    chunk_id: str
    start_pos: int
    end_pos: int
    target_article: Optional[TargetArticle] = None
    inherited_target_article: Optional[TargetArticle] = None
    # Optional structured hint parsed from phrases like
    # "Après le 5° bis du I", "Avant le 3° du II", "À la fin du III", etc.
    # Used by the reconstructor to deterministically locate anchors in the original text.
    structural_anchor_hint: Optional[Dict[str, str]] = None


# Clean Architecture Models

class OperationType(Enum):
    """Types of atomic amendment operations for clean architecture."""
    REPLACE = "REPLACE"  # "les mots X sont remplacés par les mots Y"
    DELETE = "DELETE"    # "sont supprimés", "est supprimé", "(Supprimé)"
    INSERT = "INSERT"    # "après le mot X, il est inséré Y"
    ADD = "ADD"          # "Il est ajouté un II ainsi rédigé"
    REWRITE = "REWRITE"  # "est ainsi rédigée", "est remplacée par"
    ABROGATE = "ABROGATE" # "sont abrogés", "est abrogé"


@dataclass
class AmendmentOperation:
    """Single atomic amendment operation from InstructionDecomposer."""
    operation_type: OperationType  # REPLACE, DELETE, INSERT, ADD, REWRITE, ABROGATE
    target_text: Optional[str]     # Text to find/modify ("A" in example)
    replacement_text: Optional[str] # New text ("B" in example, for REPLACE/INSERT/ADD/REWRITE)
    position_hint: str             # Legal position specification ("au 2°")
    sequence_order: int            # Order in compound operations (1, 2, 3...)
    confidence_score: float        # Decomposition confidence (0-1)

    def __post_init__(self):
        """Validate operation data after initialization."""
        if self.operation_type == OperationType.REPLACE and (not self.target_text or not self.replacement_text):
            raise ValueError("REPLACE operation requires both target_text and replacement_text")
        # Note: DELETE operations can have null target_text for simple "(Supprimé)" cases
        elif self.operation_type in [OperationType.INSERT, OperationType.ADD, OperationType.REWRITE] and not self.replacement_text:
            raise ValueError(f"{self.operation_type.value} operation requires replacement_text")
        elif self.operation_type == OperationType.ABROGATE and not self.position_hint:
            raise ValueError("ABROGATE operation requires position_hint")
            
        if not (0 <= self.confidence_score <= 1):
            raise ValueError("Confidence score must be between 0 and 1")


@dataclass
class ReconstructionResult:
    """Complete reconstruction result with detailed tracking."""
    success: bool
    final_text: str
    operations_applied: List[AmendmentOperation]
    operations_failed: List[Tuple[AmendmentOperation, str]]  # operation, error
    original_text_length: int
    final_text_length: int
    processing_time_ms: int
    validation_warnings: List[str] 


# --- Legal State Synthesis (Step 8) Models ---

@dataclass
class LegalReferenceAnnotation:
    """Annotation for a resolved reference within a synthesized legal fragment."""
    marker_index: int
    reference_text: str
    object: str
    resolved_content: str
    source: ReferenceSourceType
    start_offset: int
    end_offset: int
    retrieval_metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class LegalState:
    """Represents an annotated legal fragment (before/after)."""
    text: str
    annotations: List[LegalReferenceAnnotation]


@dataclass
class LegalAnalysisOutput:
    """Combined before/after states for a chunk with synthesis metadata."""
    before_state: LegalState
    after_state: LegalState
    metadata: Dict[str, Any]


@dataclass
class LegalStateSynthesizerConfig:
    """Configuration knobs for deterministic synthesis rendering."""
    render_mode: str = "footnote"          # footnote | inline | none
    max_resolved_chars: int = 400
    annotate_all_occurrences: bool = False
    normalize_matching: bool = True
    footnote_prefix: str = ""